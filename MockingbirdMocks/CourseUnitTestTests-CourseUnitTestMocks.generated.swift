//
//  CourseUnitTestTests-CourseUnitTestMocks.generated.swift
//  CourseUnitTest
//
//  Generated by Mockingbird v0.16.0.
//  DO NOT EDIT
//

@testable import CourseUnitTest
@testable import Mockingbird
import Foundation
import Swift
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked Add

public final class AddMock: CourseUnitTest.Add, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`validNumber`: CourseUnitTest.ValidNumber, __file: StaticString = #file, __line: UInt = #line) -> AddMock { fatalError("See 'Thunk Pruning' in the README") }

    public static func initialize(`validNumber`: CourseUnitTest.ValidNumber, `print`: CourseUnitTest.Print, __file: StaticString = #file, __line: UInt = #line) -> AddMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked print

  override public var `print`: CourseUnitTest.Print? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public func getPrint() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CourseUnitTest.Print?, CourseUnitTest.Print?> { fatalError("See 'Thunk Pruning' in the README") }

  public func setPrint(_ newValue: @escaping @autoclosure () -> CourseUnitTest.Print?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CourseUnitTest.Print?) -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked validNumber

  override public var `validNumber`: CourseUnitTest.ValidNumber { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public func getValidNumber() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CourseUnitTest.ValidNumber, CourseUnitTest.ValidNumber> { fatalError("See 'Thunk Pruning' in the README") }

  public func setValidNumber(_ newValue: @escaping @autoclosure () -> CourseUnitTest.ValidNumber) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CourseUnitTest.ValidNumber) -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `add`(_ `val1`: Int, `val2`: Int)

  public override func `add`(_ `val1`: Int, `val2`: Int) -> Int { fatalError("See 'Thunk Pruning' in the README") }

  public func `add`(_ `val1`: @escaping @autoclosure () -> Int, `val2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`validNumber`: CourseUnitTest.ValidNumber)

  public required override init(`validNumber`: CourseUnitTest.ValidNumber) { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`validNumber`: CourseUnitTest.ValidNumber, `print`: CourseUnitTest.Print)

  public required override init(`validNumber`: CourseUnitTest.ValidNumber, `print`: CourseUnitTest.Print) { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `addPrint`(`a`: Int, `b`: Int)

  public override func `addPrint`(`a`: Int, `b`: Int) -> Void { fatalError("See 'Thunk Pruning' in the README") }

  public func `addPrint`(`a`: @escaping @autoclosure () -> Int, `b`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Add.self).initialize(…)`.
public func mock(_ type: CourseUnitTest.Add.Type, file: StaticString = #file, line: UInt = #line) -> AddMock.InitializerProxy.Type {
  return AddMock.InitializerProxy.self
}

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: CourseUnitTest.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked CalculatorTemp

public final class CalculatorTempMock: CourseUnitTest.CalculatorTemp, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `convertCtoF`(_ `degree`: Double)

  public override func `convertCtoF`(_ `degree`: Double) -> Double { fatalError("See 'Thunk Pruning' in the README") }

  public func `convertCtoF`(_ `degree`: @escaping @autoclosure () -> Double) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `convertFtoC`(_ `fah`: Double)

  public override func `convertFtoC`(_ `fah`: Double) -> Double { fatalError("See 'Thunk Pruning' in the README") }

  public func `convertFtoC`(_ `fah`: @escaping @autoclosure () -> Double) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double> { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns a concrete mock of `CalculatorTemp`.
public func mock(_ type: CourseUnitTest.CalculatorTemp.Type, file: StaticString = #file, line: UInt = #line) -> CalculatorTempMock {
  return CalculatorTempMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Calculator

public final class CalculatorMock: CourseUnitTest.Calculator, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `divide`(`n1`: Int, `n2`: Int)

  public override func `divide`(`n1`: Int, `n2`: Int) throws -> Int { fatalError("See 'Thunk Pruning' in the README") }

  public func `divide`(`n1`: @escaping @autoclosure () -> Int, `n2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int, Int) throws -> Int, Int> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `add`(`val1`: Int, `val2`: Int)

  public override func `add`(`val1`: Int, `val2`: Int) -> Int { fatalError("See 'Thunk Pruning' in the README") }

  public func `add`(`val1`: @escaping @autoclosure () -> Int, `val2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `substrac`(`val1`: Int, `val2`: Int)

  public override func `substrac`(`val1`: Int, `val2`: Int) -> Int { fatalError("See 'Thunk Pruning' in the README") }

  public func `substrac`(`val1`: @escaping @autoclosure () -> Int, `val2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `intToSquared`(`val`: [Int])

  public override func `intToSquared`(`val`: [Int]) -> [Int] { fatalError("See 'Thunk Pruning' in the README") }

  public func `intToSquared`(`val`: @escaping @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns a concrete mock of `Calculator`.
public func mock(_ type: CourseUnitTest.Calculator.Type, file: StaticString = #file, line: UInt = #line) -> CalculatorMock {
  return CalculatorMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Print

public final class PrintMock: CourseUnitTest.Print, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      PrintMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `showError`()

  public override func `showError`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showError`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `showError`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showError`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `showMessage`(_ `numero`: Int)

  public override func `showMessage`(_ `numero`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showMessage`(_ `numero`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`numero`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`numero`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `showMessage`(_ `numero`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`numero`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showMessage`(_ `numero`: Int) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `Print`.
public func mock(_ type: CourseUnitTest.Print.Type, file: StaticString = #file, line: UInt = #line) -> PrintMock {
  return PrintMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: CourseUnitTest.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked StringManager

public final class StringManagerMock: CourseUnitTest.StringManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `messageToLowercase`(_ `string`: String)

  public override func `messageToLowercase`(_ `string`: String) -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `messageToLowercase`(_ `string`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `messageToUppercase`(_ `string`: String)

  public override func `messageToUppercase`(_ `string`: String) -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `messageToUppercase`(_ `string`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns a concrete mock of `StringManager`.
public func mock(_ type: CourseUnitTest.StringManager.Type, file: StaticString = #file, line: UInt = #line) -> StringManagerMock {
  return StringManagerMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ValidNumber

public final class ValidNumberMock: CourseUnitTest.ValidNumber, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      ValidNumberMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `check`(_ `number`: Int)

  public override func `check`(_ `number`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`check`(_ `number`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`number`)], returnType: Swift.ObjectIdentifier((Bool).self))
    return self.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Bool {
        return concreteImplementation(`number`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `check`(_ `number`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`number`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`check`(_ `number`: Int) -> Bool", arguments: arguments, returnType: Swift.ObjectIdentifier((Bool).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `ValidNumber`.
public func mock(_ type: CourseUnitTest.ValidNumber.Type, file: StaticString = #file, line: UInt = #line) -> ValidNumberMock {
  return ValidNumberMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ViewController

public final class ViewControllerMock: CourseUnitTest.ViewController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "CourseUnitTest"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ViewControllerMock? { fatalError("See 'Thunk Pruning' in the README") }

    public static func initialize(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ViewControllerMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked `viewDidLoad`()

  public override func `viewDidLoad`() -> Void { fatalError("See 'Thunk Pruning' in the README") }

  public func `viewDidLoad`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: String?, `bundle` `nibBundleOrNil`: Bundle?) { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(ViewController.self).initialize(…)`.
public func mock(_ type: CourseUnitTest.ViewController.Type, file: StaticString = #file, line: UInt = #line) -> ViewControllerMock.InitializerProxy.Type {
  return ViewControllerMock.InitializerProxy.self
}
